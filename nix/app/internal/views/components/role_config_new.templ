package components

import (
	"fmt"
	"treacherest/internal/config"
	"treacherest/internal/game"
)

type RoleTypeDisplay struct {
	TypeName string
	Config   *game.RoleTypeConfig
	Cards    []CardDisplay
}

type CardDisplay struct {
	Name    string
	Enabled bool
}

templ RoleConfigurationNew(room *game.Room, cfg *config.ServerConfig, cardService *game.CardService) {
	<div id="role-config" class="role-configuration" data-signals="{cardId: '', cardChecked: false, roleType: '', roleCount: 0, action: ''}"
		 data-signals__ifmissing="{accordionLeader: false, accordionGuardian: false, accordionAssassin: false, accordionTraitor: false}"
			>
		<h3>Game Configuration</h3>
		// Player count settings
		<div class="player-count-config">
			<label>Player Count:</label>
			<div class="player-range">
				if room.RoleConfig.MinPlayers == room.RoleConfig.MaxPlayers {
					<span>{ fmt.Sprintf("%d players", room.RoleConfig.MinPlayers) }</span>
				} else {
					<span>{ fmt.Sprintf("%d - %d players", room.RoleConfig.MinPlayers, room.RoleConfig.MaxPlayers) }</span>
				}
			</div>
		</div>
		// Preset selector
		<div class="preset-selector">
			<form id="preset-form" data-on-change={ "@post('/room/" + room.Code + "/config/preset', {contentType: 'form'})" }>
				<label for="role-preset">Role Preset:</label>
				<select
					id="role-preset"
					name="preset"
				>
					<option value="custom" selected?={ room.RoleConfig.PresetName == "custom" }>Custom</option>
					for presetName := range cfg.Roles.Presets {
						<option value={ presetName } selected?={ room.RoleConfig.PresetName == presetName }>
							{ presetName }
						</option>
					}
				</select>
			</form>
		</div>
		// Advanced options
		<div class="advanced-options" data-signals__ifmissing={ fmt.Sprintf(`{allowLeaderless: %t, enableAutoScale: true, updatingLeaderless: false}`, room.RoleConfig.AllowLeaderlessGame) }>
			<h4>Advanced Options</h4>
			<div class="option-item">
				<input
					type="checkbox"
					id="allow-leaderless"
					checked?={ room.RoleConfig.AllowLeaderlessGame }
					data-bind="allowLeaderless"
					data-attr-disabled="$updatingLeaderless"
					data-on-change={ fmt.Sprintf(`$updatingLeaderless = true; @post('/room/%s/config/leaderless', {body: JSON.stringify({allowed: $allowLeaderless})})`, room.Code) }
				/>
				<label for="allow-leaderless">
					Allow Leaderless Games
					<span class="option-description">(Enables games without a Leader role)</span>
					<span data-show="$updatingLeaderless" class="loading loading-spinner loading-xs ml-2"></span>
				</label>
			</div>
			
			// Auto-scale toggle - only show for preset configurations
			if room.RoleConfig.PresetName != "custom" {
				<div class="option-item" 
					data-show="$canAutoScale"
					data-attr-title="$autoScaleDetails">
					<input
						type="checkbox"
						id="enable-auto-scale"
						checked?={ true }
						data-bind="enableAutoScale"
						data-attr-disabled="!$canAutoScale"
					/>
					<label for="enable-auto-scale">
						Auto-scale roles for player count
						<span class="option-description">({ room.RoleConfig.PresetName } preset will adjust roles automatically)</span>
					</label>
				</div>
				
				// Show auto-scale details when relevant
				<div class="auto-scale-info" data-show="$canAutoScale && $autoScaleDetails">
					<span class="info-icon">ℹ️</span>
					<span data-text="$autoScaleDetails" class="text-sm"></span>
				</div>
			}
		</div>
		// Role types with collapsible sections
		<div class="role-settings">
			<h4>Roles</h4>
			<div class="join join-vertical w-full">
				@RoleTypeSection(room, "Leader", room.RoleConfig.RoleTypes["Leader"], cardService.Leaders)
				@RoleTypeSection(room, "Guardian", room.RoleConfig.RoleTypes["Guardian"], cardService.Guardians)
				@RoleTypeSection(room, "Assassin", room.RoleConfig.RoleTypes["Assassin"], cardService.Assassins)
				@RoleTypeSection(room, "Traitor", room.RoleConfig.RoleTypes["Traitor"], cardService.Traitors)
			</div>
		</div>
		// Validation messages
		<div id="role-validation" class="validation-messages">
			// Validation messages will be inserted here via SSE
		</div>
	</div>
}

templ RoleTypeSection(room *game.Room, typeName string, typeConfig *game.RoleTypeConfig, cards []*game.Card) {
	if typeConfig == nil {
		<div class="flex items-start gap-4 join-item border border-base-300 p-2">
			<div class="w-20"></div> <!-- Adjusted spacer for wider buttons -->
			<div class="py-3">
				<span class="font-bold">{ typeName }s</span>
				<span class="text-warning ml-2">Not configured</span>
			</div>
		</div>
	} else {
		<div class="join-item border border-base-300
					grid grid-cols-5 grid-rows-1
					auto-cols-max w-full
					">
			<div class="grid grid-cols-1 grid-rows-3">
				<!-- Left controls - wider buttons -->
					<button
						class="btn btn-primary
							   row-start-1
							   "
						data-on-click={ fmt.Sprintf(`@post('/room/%s/config/role-type/%s/increment')`, room.Code, typeName) }
					>+</button>
					<span class="text-lg font-bold my-1 row-start-2 text-center">{ fmt.Sprintf("%d", typeConfig.Count) }</span>
					<button 
						class="btn btn-primary
							   row-start-3
							   "
						data-on-click={ fmt.Sprintf(`@post('/room/%s/config/role-type/%s/decrement')`, room.Code, typeName) }
						disabled?={ typeConfig.Count == 0 }
					>-</button>
			</div>

				<!-- Accordion part -->
				<div class="collapse collapse-arrow row-start-1 col-start-2 col-span-4 transition-all duration-100">
					<input type="checkbox" name={ fmt.Sprintf("accordion-%s", typeName) } id={ fmt.Sprintf("role-accordion-%s", typeName) }
						   data-bind={ fmt.Sprintf("accordion%s", typeName) }
						   class="peer/roletype sr-only"
					/>
					<label for={ fmt.Sprintf("role-accordion-%s", typeName) } class=" absolute inset-0 z-10 collapse-title h-full font-bold items-center p-8
							   peer-checked/roletype:static
							   peer-checked/roletype:h-auto
							   peer-checked/roletype:z-auto
							   peer-checked/roletype:bg-transparent hover:bg-base-300
							   transition
							   peer-checked/roletype:delay-100
							   ">
						{ typeName }s
						if typeConfig.Count > countEnabledCards(typeConfig) {
							<span class="text-warning ml-2 text-sm">⚠️ { fmt.Sprintf("%d of %d cards enabled", countEnabledCards(typeConfig), typeConfig.Count) }</span>
						} else if typeConfig.Count > 0 {
							<span class="text-success ml-2">✓</span>
						}
					</label>
					<div class="collapse-content">
						<div class="space-y-2 pt-2" data-show={ fmt.Sprintf("$accordion%s", typeName) }>
							for _, card := range cards {
								<div class="form-control">
									<label class="label cursor-pointer justify-start gap-2">
										<input
											type="checkbox"
											class="toggle"
											id={ fmt.Sprintf("card-%s-%s", typeName, card.NameAnchor) }
											checked?={ typeConfig.EnabledCards[card.Name] }
											data-on-click={ fmt.Sprintf(`$cardId = evt.target.id; $cardChecked = evt.target.checked; @post('/room/%s/config/card-toggle')`, room.Code) }
										/>
										<span class="label-text">{ card.Name }</span>
									</label>
								</div>
							}
						</div>
					</div>
				</div>
		</div>
	}
}


func countEnabledCards(typeConfig *game.RoleTypeConfig) int {
	count := 0
	for _, enabled := range typeConfig.EnabledCards {
		if enabled {
			count++
		}
	}
	return count
}
